  <!DOCTYPE html>
  <html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src='plotly.js'></script>
  </head>

  <body>
  <p>This site downloads resources and guesses their size based on how long it takes to download. For each guess, it downloads a resource of known size 1B and 300KB. It then downloads the unknown resource and estimates its size with linear interpolation. This is repeated 10 times per unknown size and the median result is taken as the final guess.</p>
    
    
  <div id="status">Gathering network samples...</div>
  <div id="result"></div>
  <div id="guessPlot" style="width:900px;height:400px;"></div>  
  <div id="distPlot" style="width:900px;height:400px;"></div>   
    

    
  <script>
  function median(d) {
    return percentile(d, 0.5);
  }

  function percentile(d, target) {
    let data = d.slice(0);  // clone d
    data.sort(function(a, b){return a - b});
    let count = 0;
    for (val of data) {
      count += 1;
      if ((count / d.length) >= target)
        return val;
    }
    return -1;
  }

  async function timeResourceLoad(size, iteration) {
    let url = 'https://cr2.kungfoo.net/jkarlin/timing/size.php?size=' + size + '?iteration=' + iteration;
    return new Promise(async function(resolve, reject) {
      let response = await fetch(url, {mode: 'no-cors'});
      startTime = window.performance.now();
      let interval = setInterval(() => {
        let entries = performance.getEntries();
        var lastEntry = entries[entries.length - 1];
        if (lastEntry.name == url) {
          clearInterval(interval);
          resolve(lastEntry.respondEnd - startTime);
        }
      },10);
    });
  }
    
  // Creates a link rel=prefetch and times how long the resource load takes.
  async function timeResourceLoadOld(size) {
    var link = document.createElement('link');
    link.rel = "prefetch";

    return new Promise(function(resolve, reject) {
      let startTime = window.performance.now();
      link.onerror = function() {
        console.log("OnError");
        let endTime = window.performance.now();
        resolve(endTime - startTime);
      }
      link.onload = function() {
        let endTime = window.performance.now();
        resolve(endTime - startTime);
      }

      link.href =
          "https://cr2.kungfoo.net/jkarlin/timing/size.php?size=" + size;
      document.body.appendChild(link);
    });
  }

  async function guessSize(size, iteration) {
    let small = 1;
    let large = 1024 * 300;

    // Sample small
    let smallTime = await timeResourceLoad(small, iteration);
    // Sample unknown
    let unknownTime = await timeResourceLoad(size, iteration);
    // Sample large
    let largeTime = await timeResourceLoad(large, iteration);

    rangeTime = largeTime - smallTime;
    unRangeTime = unknownTime - smallTime;

    // Linear interpolation to guess size
    guess = unRangeTime / rangeTime * (large - small);

    return guess;
  }

  (async function() {
    let numGuesses = 1;
    let samplesPerGuess = 1;
    let deltas = [];
    let actualBytes = [];
    let guessedBytes = [];

    for (let i = 0; i < numGuesses; i++) {
      // Grab a sample to predict of random size
      let bytes = Math.floor(Math.random() * 1024 * 300);
      let guesses = [];
      for (let i = 0; i <= samplesPerGuess; i++) {
        let guess = await guessSize(bytes, i);
        guesses.push(guess);
      }
      let guess = median(guesses);
      delta = Math.abs(guess - bytes);
      deltas.push(delta);
      actualBytes.push(bytes);
      guessedBytes.push(guess);
    }

    result = document.getElementById('result');
    resultMsg = "Median delta is " + Math.floor(median(deltas) / 1024) +
                "KB and 90th percentile delta is " +
                Math.floor(percentile(deltas, 0.9) / 1024) + 'KB';
    result.appendChild(document.createTextNode(resultMsg));

    // Plot a scatter plot showing guessed vs actual
    let plotDiv = document.getElementById('guessPlot');
    let scatterGuess = {
      x : actualBytes,
      y : guessedBytes,
      mode : 'markers',
      type : 'scatter',
      name : 'actual vs estimate'
    };
    let xEqualsY = {
      x : actualBytes,
      y : actualBytes,
      mode : 'lines',
      type : 'scatter',
      name : 'x=y'
    };
    Plotly.plot(plotDiv, [scatterGuess, xEqualsY], {
      xaxis : {
      title:
        'Actual'
      }
        , yaxis : {title : 'Predicted bytes'}, title : 'Predictions'
    });

  // Plot the CDF of deltas
  plotDiv = document.getElementById('distPlot');
  let cdfX = [];
  let cdfY = [];
  let curCount = 0;
  deltas.sort(function(a, b) {
      return a - b
  });
  for (let delta of deltas) {
    cdfX.push(delta);
    cdfY.push((curCount + 1) / deltas.length);
    curCount += 1;
  }
  let cdf = {x : cdfX, y : cdfY, type : 'scatter', mode : 'lines'};
  Plotly.plot(plotDiv, [cdf], { xaxis : { title:'Bytes delta' }, yaxis : {title : 'CDF of abs(actual-predicted)'},
            title : 'Prediction Delta CDF'
  });

  })();
  </script>
  </body>
