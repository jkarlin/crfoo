  <!DOCTYPE html>
  <html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src='plotly.js'></script>
    <script src='regression.js'></script>
  </head>

  <body>
    <p>This site downloads opaque resources of various sizes and plots the distributions of the time between resource start and end from the network. This gives us an idea of how accurate network timing attacks may be.</p>

    
    <div id="status">Gathering samples...</div>
    <div id="plot" style="width:900px;height:400px;"></div>

    <script>

      const kMaxPow = 7;
      const kSamplesPerSize = 40;
      const kWarmUpCount = 20;
      let numSamples = 10;
      
      performance.setResourceTimingBufferSize(kSamplesPerSize * (kMaxPow + 1) + kWarmUpCount + numSamples * kSamplesPerSize);

      // Creates a link rel=prefetch and times how long the resource load takes.
      let resourceCount = 0;
      async function timeResourceLoad(size) {
        var link = document.createElement('link');
        link.rel = "prefetch";

        return new Promise(function(resolve, reject) {
          let url = "https://cr2.kungfoo.net/jkarlin/timing/size.php?size=" + size + '?count=' + resourceCount++;
          link.onerror = function() {
            console.log("OnError");
            let perf_entry = window.performance.getEntriesByName(url, 'resource')[0];
            resolve(perf_entry.responseEnd - perf_entry.startTime);
          }
          link.onload = function() {
            let perf_entry = window.performance.getEntriesByName(url, 'resource')[0];
            resolve(perf_entry.responseEnd - perf_entry.startTime);
          }

          link.href = url;
          document.body.appendChild(link);
        });
      }

      function standardDeviation(values){
        let avg = mean(values);

        let squareDiffs = values.map(function(value){
          var diff = value - avg;
          var sqrDiff = diff * diff;
          return sqrDiff;
        });

        let avgSquareDiff = mean(squareDiffs);

        let stdDev = Math.sqrt(avgSquareDiff);
        return stdDev;
      }

      function sampleStandardError(values) {
       return sampleStandardDeviation(values) / Math.sqrt(values.length) 
      }

      function sampleStandardDeviation(values){
        let avg = mean(values);
        
        let sum_diffs = 0;
        for (i of values) {
         let diff = i - avg;
         sum_diffs += diff * diff;
        }
        
        return Math.sqrt(sum_diffs / (values.length - 1))
      }      
      
      // returns slope, intercept and r-square of the line
      // from: http://bl.ocks.org/benvandyke/8459843
      function leastSquares(xSeries, ySeries) {
        var reduceSumFunc = function(prev, cur) { return prev + cur; };

        var xBar = xSeries.reduce(reduceSumFunc) * 1.0 / xSeries.length;
        var yBar = ySeries.reduce(reduceSumFunc) * 1.0 / ySeries.length;

        var ssXX = xSeries.map(function(d) { return Math.pow(d - xBar, 2); })
          .reduce(reduceSumFunc);

        var ssYY = ySeries.map(function(d) { return Math.pow(d - yBar, 2); })
          .reduce(reduceSumFunc);

        var ssXY = xSeries.map(function(d, i) { return (d - xBar) * (ySeries[i] - yBar); })
          .reduce(reduceSumFunc);

        var slope = ssXY / ssXX;
        var intercept = yBar - (xBar * slope);
        var rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);

        return [slope, intercept, rSquare];
      }      
      
      function median(d) {
        return percentile(d, 0.5);
      }

      function percentile(d, target) {
        let data = d.slice(0);  // clone d
        data.sort(function(a, b){return a - b});
        let count = 0;
        for (val of data) {
          count += 1;
          if ((count / d.length) >= target)
            return val;
        }
        return -1;
      }

      function mean(d) {
        let sum = 0;
        for (val of d)
          sum += val;
        return sum / d.length;
      }

      function stripOutliers(d) {
        // An outlier is a point more than 1.5 IQR's below the first quartile
        // or above the third.
        let q1 = percentile(d, 0.25);
        let q3 = percentile(d, 0.75);
        let iqr = q3-q1;
        let min = q1 - iqr*1.5;
        let max = q3 + iqr*1.5;

        out = [];
        for (val of d) {
          if (val >= min && val <= max)
            out.push(val);
        }
        return out;
      }

      function stderr(d) {
        return standardDeviation(d) / Math.sqrt(d.length);
      }

      function stderrOfMedian(d) {
        return stderr(d) * 1.253
      }
      
      async function guessSize(size, x_data, y_data) {
        let samples = []
        for (let i = 0; i < kSamplesPerSize; i++) {
           let time = await timeResourceLoad(size);
           samples.push(time)
        }
        let sample_mean = mean(stripOutliers(samples));

        // Find the highest value of y_data that this is above.
        let above_index = -1;
        let below_index = -1;
        console.log("Sample mean = " + sample_mean);
        for(let i = 0; i < y_data.length; i++) {      
          if (sample_mean > y_data[i]) {
            below_index = i;
            above_index = i+1;
          }
        }
       
        if (below_index == y_data.length-1) {
          above_index = y_data.length - 1;
        }
        
        console.log("Above index = " + above_index + " below index = " + below_index);
        console.log(y_data);

        let y_delta = y_data[above_index] - y_data[below_index];
        let x_delta = x_data[above_index] - x_data[below_index];
        let slope = y_delta / x_delta;
        console.log(slope + " " + x_delta + " " + y_delta);
        let guess = x_data[below_index] + slope * (sample_mean - y_data[below_index]);

        console.log("Guess = " + guess + " actual size = " + size);
        return guess;
      }      

    (async function() {
      for(let i = 0; i < kWarmUpCount; i++)
        await timeResourceLoad(1024 * 100); // warm up the network

      all_times = {}
      let x_data = []
      
      
      for (let exp = kMaxPow-1; exp >= 0; exp--) {
        let bytes = 1024 * Math.pow(2, exp);
        x_data.push(bytes)
        let times = [];
        for (let attempt = 0; attempt < kSamplesPerSize; attempt++) {
          time = await timeResourceLoad(bytes);
          times.push(time);
        }
        all_times[bytes] = times;
      }
      
      // Flip the samples so that they're from low to high
      x_data = x_data.reverse();
      
      let y_data = []
      let xy_data = []
      let y_error = []
      for(bytes of x_data) {
        let d = stripOutliers(all_times[bytes])
        //let d = all_times[bytes]
        y_data.push(mean(d))
        xy_data.push([bytes, mean(d)])
        y_error.push(sampleStandardError(d))
       }

//       for(var key in all_times) {
//        let d = all_times[key]
      //         y_data.push(median(d))
//         xy_data.push([key, median(d)])
//         y_error.push(stderrOfMedian(d))
//       }

      let fitdata = leastSquares(x_data, y_data)
      let slope = fitdata[0]
      let y_intercept = fitdata[1]
//       console.log("xy_data " + xy_data);
//       let reg = regression('linear', xy_data);
//       let slope = reg.equation[0]
//       let y_intercept = reg.equation[1]
//       console.log("points = " + reg.points)
      // Plot the results
      let data =
        {
          x: x_data,
          y: y_data,
          error_y: {
            type: 'data',
            array: y_error,
            visible: true
          },
          type: 'scatter'
        }
      console.log("slope = " + slope);
      console.log("y_intercept = " + y_intercept)

      let y_fit = []
      for(i of x_data)
        y_fit.push(slope*i + y_intercept);

      let fit =
        {
          x: x_data,
          y: y_fit,
          type: 'line',
        }


      // for(var i = 0; i < x_data.length; i++) {
      //   bytes = x_data[i];
      //   var result = {
      //     type: 'scatter',
      //     y: mean(all_times[bytes]),
      //     name: x_data[i],
      //     // boxpoints: 'false',
      //     // jitter: 0.5,
      //     // whiskerwidth: 0.6,
      //     // fillcolor: 'cls',
      //     // boxmean: 'sd',
      //   }
      //   data.push(result)
      // }

      layout = {
          title: 'Sample Mean Time of Network Fetches',
          yaxis: {
              title: 'Time in milliseconds',
//               autorange: true,
//               showgrid: true,
//               zeroline: true,
//               dtick: 5,
//              gridcolor: 'rgb(255, 255, 255)',
//               gridwidth: 1,
//              zerolinecolor: 'rgb(255, 255, 255)',
//               zerolinewidth: 2
          },
          xaxis: {
            // type: 'log',
            autorange: true,
            title: 'Size in bytes'
          },
          // margin: {
          //     l: 40,
          //     r: 30,
          //     b: 80,
          //     t: 100
          // },
          paper_bgcolor: 'rgb(243, 243, 243)',
          plot_bgcolor: 'rgb(243, 243, 243)',
          showlegend: false
      };

      Plotly.newPlot('plot', [data], layout);


    let results = []
    for (let i = 0; i < numSamples; i++) {
      let bytes = Math.floor(Math.random() * 1024 * Math.pow(2, kMaxPow-1));
      let guess = await guessSize(bytes, x_data, y_data);
      let error = Math.abs(guess - bytes);
      results.push([bytes, guess, error])
    }
    
    console.log(results);
      
      
    })();
      
</script>
</body>
</html>
